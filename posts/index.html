<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Posts | Beoning</title>
<meta name=keywords content>
<meta name=description content="Posts - Beoning">
<meta name=author content="Max">
<link rel=canonical href=https://www.soundpill.cn/posts/>
<meta name=google-site-verification content="XYZabc">
<meta name=yandex-verification content="XYZabc">
<meta name=msvalidate.01 content="XYZabc">
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<link rel=preload href=https://s2.loli.net/2022/01/17/bnDIUk5RZhK2CgY.png as=image>
<link rel=icon href=https://www.soundpill.cn/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=16x16 href=https://www.soundpill.cn/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=32x32 href=https://www.soundpill.cn/%3Clink%20/%20abs%20url%3E>
<link rel=apple-touch-icon href=https://www.soundpill.cn/%3Clink%20/%20abs%20url%3E>
<link rel=mask-icon href=https://www.soundpill.cn/%3Clink%20/%20abs%20url%3E>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.0">
<link rel=alternate type=application/rss+xml href=https://www.soundpill.cn/posts/index.xml>
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-123-45','auto'),ga('send','pageview'))</script><meta property="og:title" content="Posts">
<meta property="og:description" content="我的个人博客">
<meta property="og:type" content="website">
<meta property="og:url" content="https://www.soundpill.cn/posts/"><meta property="og:image" content="https://www.soundpill.cn/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="Beoning">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://www.soundpill.cn/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E">
<meta name=twitter:title content="Posts">
<meta name=twitter:description content="我的个人博客">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.soundpill.cn/posts/"}]}</script>
</head>
<body class=list id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://www.soundpill.cn/ accesskey=h title="Beoning (Alt + H)">
<img src=https://s2.loli.net/2022/01/17/bnDIUk5RZhK2CgY.png alt=logo aria-label=logo height=35>Beoning</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
</ul>
</nav>
</header>
<main class=main>
<header class=page-header><div class=breadcrumbs><a href=https://www.soundpill.cn/>Home</a></div>
<h1>Posts</h1>
</header>
<article class=post-entry>
<header class=entry-header>
<h2>由 append 引发的一个疑问<sup><span class=entry-isdraft>&nbsp;&nbsp;[draft]</span></sup>
</h2>
</header>
<section class=entry-content>
<p>由 append 引发的一个疑问 我们先来看一个问题
package main import "fmt" func main() { a := make([]int, 0, 5) AddElm(a, 5) fmt.Println(a) } func AddElm(a []int, i int) { a = append(a, i) } 上面这一段代码中，a 这个切片会输出什么呢？可以试着运行一下
答案是空切片，为什么呢？首先我们知道 append 这个操作，在容量足够的情况下是不会新生成一个 slice 来进行扩容的，所以这里排除这种情况。
已知这个 slice 也是值传递的方式传入的，那么是不是因为他 copy 了一份数据到函数内部从而导致的函数内外不一致的情况呢？我们打印地址看一下
package main import "fmt" func main() { a := make([]int, 0, 5) fmt.Printf("before: %p\n", a) AddElm(a, 5) fmt.Printf("after: %p\n", a) fmt.Println(a) } func AddElm(a []int, i int) { a = append(a, i) fmt....</p>
</section>
<footer class=entry-footer><span title="2022-02-20 18:02:55 +0800 CST">February 20, 2022</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Max</footer>
<a class=entry-link aria-label="post link to 由 append 引发的一个疑问" href=https://www.soundpill.cn/posts/2022-02-20-golang-slice-question/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>golang 中提防竞态条件的产生<sup><span class=entry-isdraft>&nbsp;&nbsp;[draft]</span></sup>
</h2>
</header>
<section class=entry-content>
<p>我们来看下面这段代码：
package main import ( "time" ) type testInt struct { Num int } func main() { a := make([]int, 0) for i := 1; i &lt; 10; i++ { a = append(a, i) } t := testInt{Num: 1} for _, v := range a { go func(i int) { t.Num = i pTs(t) }(v) } time.Sleep(time.Second*3) } func pTs(t testInt) { println(t.Num) } 你可以复制出来执行一下，会不会有问题呢？从执行的结果来看，是没问题的。 但是如果你要加上 -race 参数去执行，就会发现在 t.Num = i 这里报错了，这是为什么呢？ 这就要说到一个 go 语言的编程常识了(可能不限语言)，就是在多个协程去处理一个变量的时候记得要加锁或者用 atomic 进行原子操作，不管结果是否正常。因为如果不这么做，有天出了问题可是不好排查的。...</p>
</section>
<footer class=entry-footer><span title="2022-02-09 22:33:25 +0800 CST">February 9, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Max</footer>
<a class=entry-link aria-label="post link to golang 中提防竞态条件的产生" href=https://www.soundpill.cn/posts/2022-02-09-go-race-data/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>控制 goroutine 执行顺序的一例<sup><span class=entry-isdraft>&nbsp;&nbsp;[draft]</span></sup>
</h2>
</header>
<section class=entry-content>
<p>依次打印 题目：依次输出 dog、pig、sheep，并执行 100 次，每个输出都需要一个单独的 goroutine
这里我们通过有缓冲的容量为 1 的 channel 来标记状态，通过 for-select 结构来控制当前要输出哪一个单词，因为 select 在 channel 阻塞的时候不会执行对应的 case，我们可以通过这个特性来操作。
具体思路如下：
设置三个 channel，初始化时使 dog 的 channel 中有一条数据，这样 select 就会先输出 dog 然后在 dog 的 case 中结束的时候给 pig 的 channel 中新增一条数据，这样下次就会进入 pig 的 case 进行输出操作 过程中我们可以使用 atomic 包来控制次数，不会产生并发问题 具体代码如下：
package main import ( "fmt" "sync" "sync/atomic" ) var wg sync.WaitGroup var counter uint64 = 0 var dogChan = make(chan struct{}, 1) var pigChan = make(chan struct{}, 1) var sheepChan = make(chan struct{}, 1) func main() { wg....</p>
</section>
<footer class=entry-footer><span title="2022-02-08 22:14:29 +0800 CST">February 8, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Max</footer>
<a class=entry-link aria-label="post link to 控制 goroutine 执行顺序的一例" href=https://www.soundpill.cn/posts/2022-02-08-go-alter-print/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>推荐两个学习 go 的网站<sup><span class=entry-isdraft>&nbsp;&nbsp;[draft]</span></sup>
</h2>
</header>
<section class=entry-content>
<p>一个就是 exercism, 这里不光可以练习 go 的基本语法和常识，还可以选择其他的语言，大部分的编程语言都是可以学习的，通过一个个任务去完成来掌握一门编程语言，很有成就感。
在掌握了基本的语法后就需要项目来练手，但是不知道应该写些什么东西的时候可以参考gophercises这个网站，里面会有各种练手项目，比如如何生成一个短链接，如何制作一个文件重命名工具等等。
经过两个网站的学习，再加上一点点悟性，相信很快就可以上手了</p>
</section>
<footer class=entry-footer><span title="2022-01-22 17:24:26 +0800 CST">January 22, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Max</footer>
<a class=entry-link aria-label="post link to 推荐两个学习 go 的网站" href=https://www.soundpill.cn/posts/2022-01-22-study-go-website/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>用 go 实现一个简易聊天室
</h2>
</header>
<section class=entry-content>
<p>概述 first，我们需要创建一个房间，可以使用 net 包直接启动一个常驻的 tcp 服务 second，我们需要有用户的信息，用户通过访问 tcp 服务来进入房间 end，我们需要在用户进入/离开房间时对其他用户进行广播，还需要将用户在房间内产生的消息发送到房间里让其他用户看见
实现 我们通过设定三个 channel 来分别标记用户进入房间、用户离开房间和用户广播消息的存储。 首先，我们创建一个 tcp 服务器，新建一个 server.go 的文件，然后通过 net 包来初始化 tcp 服务器，端口就选择 2022。监听器创建完毕后我们可以看到它里面有三个方法，分别是 Accept、Close 和 Addr，Close 就是用来关闭这个端口监听，Addr 就是返回监听器所对应的 ip，这里默认的话也就是本地的 ip，Accept 方法就是返回一个连接，一旦有人请求这个文件，就意味着产生一个连接，如果没有人请求那么 Accept 就会等待，这里我们用一个死循环来让它可以重复的接受多个连接请求。
listener, err := net.Listen("tcp", ":2022") if err != nil { panic(err) } for { conn, err := listener.Accept() if err != nil { log.Println(err) continue } go handleConn(conn) } 然后就是 handleConn 这个方法，将每次的连接传入进去，然后初始化连接的用户信息，再通过一个协程将用户消息通道里的信息拿出来消费，接下来做的就是向用户进入/离开的消息 channel 中写入该用户已经上线或用户离开的消息，然后再将用户记录到用户列表中。最后通过扫描该连接来读取用户的输入内容。
func handleConn(conn net....</p>
</section>
<footer class=entry-footer><span title="2022-01-22 16:27:33 +0800 CST">January 22, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;max</footer>
<a class=entry-link aria-label="post link to 用 go 实现一个简易聊天室" href=https://www.soundpill.cn/posts/2022-01-22-go-simple-chatroom/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>将视频切割为均等的时间长度
</h2>
</header>
<section class=entry-content>
<p>前情提要 有时候在某些软件中将单次可发送的视频时长限制为 5 分钟或者 15 分钟, 总之就是一个固定的长度, 这样在我们发送超过时长的视频时会比较不方便.
所以写一段程序来自动按照传入的时间来等分视频.
当然这只是其中一个场景.
利用 goroutine 和 FFmpeg 首先获取视频长度信息可以通过 ffprobe 命令来获取, 这个是 FFmpeg 下的一个工具包, 安装 FFmpeg 后就会有了.
然后拿到视频总时长后根据传入的分钟数来分割视频, 这时候就需要用到 ffmpeg 命令了.
最后启动 goroutine 来异步分割每一段视频, 最终完成.
工具地址 https://github.com/muyehub/cut_video_avg</p>
</section>
<footer class=entry-footer><span title="2021-12-02 14:48:45 +0800 CST">December 2, 2021</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;max</footer>
<a class=entry-link aria-label="post link to 将视频切割为均等的时间长度" href=https://www.soundpill.cn/posts/2021-12-02-cut-video-avg/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>golang 编程陷阱---摘自《go 专家编程》
</h2>
</header>
<section class=entry-content>
<p>关于切片扩容 在使用 append 向 slice 中追加元素时，如果 slice 容量不足以存储新元素，则会把当前切片扩容并产生一个新的切片。如下：
package main import "fmt" func main() { s := make([]int, 0) w := append(s, 1) t := append(s, 2) v := append(s, 3) fmt.Printf("%p, %p , %p , %p, %p", s, w, t, v) } // 0x116ce80, 0xc00001c198 , 0xc00001c1a0 , 0xc00001c1a8 append 会每次都生成一个新的切片，并且每次都会做扩容操作，元切片 s 并没有改变任何。
所以，在操作中要将 append 的返回值接收，如果不接收编译器会报错，如果用 _ 忽略返回值，则需要考虑扩容的情况，避免滥用。
空切片 向 slice 中 append 空值(nil)时也会增加 slice 的长度，这在有些情况下可能会导致严重的错误，并且不易察觉，书中举了一个 Kubernetes 项目中的例子。
有一个错误收集器，用来将验证函数的一系列错误收集到一个 slice 中，检查 slice 的长度如果大于 0 时，说明有错误产生，则程序退出，如下：...</p>
</section>
<footer class=entry-footer><span title="2021-11-02 23:47:33 +0800 CST">November 2, 2021</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;max</footer>
<a class=entry-link aria-label="post link to golang 编程陷阱---摘自《go 专家编程》" href=https://www.soundpill.cn/posts/2021-11-02-golang-coding-trap/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>php-tips
</h2>
</header>
<section class=entry-content>
<p>在 foreach 中不要使用 array_merge，不仅慢而且耗费内存，可以在 foreach 中对要合并的数组进行赋值，在 foreach 外部统一进行合并，具体性能差异可以参考这篇文章：不要在循环体中使用 array_merge()
在 foreach 中也不要使用 array_push，可以通过向数组中赋值的方式代替，比如：$students[] = $student[‘id’]， 而不是 array_push($students, $student[‘id’])，具体性能差异可以参考这篇文章：不要在循环体中使用 array_push()
针对一些查询较为复杂或者比较核心的逻辑里的 sql 查询，可以将 sql 语句写到注释中，这样看代码的时候不用再去拼接 sql，直接用注释中的 sql 拿来排查问题
如果使用 phpstorm 可以安装 php inspections 插件来进行代码的静态分析，可以帮助查找代码规范，语法漏洞，函数使用方式方面的错误。其他的一些代码质量工具可以配置使用 phpcs，phpmd，phpcs-fixer，psalm，phpstan 等。而且可以通过 phpstorm 的热键录制功能，将徽标键 + s 设置为 phpcs-fixer，format code 的快捷键，这样写完时可以通过快捷键格式化代码。
为避免在项目中将 dd，var_dump，exit，die 等函数提交到远程版本库中，可以在项目的 .git/hooks/pre-commit 中进行控制，加入下面的代码，每次提交时可以检测到。参考的这个：pre-commit
VAR=$(git diff --cached --diff-filter=ACMR | grep -wiE "var_dump|echo|exit|dd|die|console.log") if [ !...</p>
</section>
<footer class=entry-footer><span title="2021-08-16 19:03:01 +0800 CST">August 16, 2021</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;max</footer>
<a class=entry-link aria-label="post link to php-tips" href=https://www.soundpill.cn/posts/2021-08-16-php-tips/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>go-tips
</h2>
</header>
<section class=entry-content>
<p>当把时间作为一个变量传递时，可能会导致的问题，比如： waitTime := 30 wait := waitTime * time.Second 这样子是错误的，因为 waitTime 不是 time.Duration 类型，但如果直接写 30 * time.Second 就会成功 在不太了解的情况下，我手动把 waitTime 通过“诡异”的方式变成了 time.Duration 类型
waitTime := 30 * time.Second wait := waitTime * time.Second 这种情况下 wait 的值就变成了 88 万小时，不是预想的结果，正确的写法如下：
waitTime := 30 wait := time.Duration(waitTime) * time.Second 当 waitGroup 使用时要清楚的知道 Done 方法的执行次数，如果是类似递归的结构，执行了多次 Done 方法，则会导致waitGroup 的计数器溢出，导致边界错误，如下： 这段代码运行时会导致 panic: sync: negative WaitGroup counter，所以我们在实际编写代码的过程中，如果有类似的情况，可以通过将有限次数的递归转换为迭代的形式来规避这种问题。总之，你需要明确的知道 Done 方法执行了几次。
在 goroutine 使用的过程中我们是无法拿到当前 goroutine 的报错信息的，从而可能需要额外建立一个通道，将报错信息传递到某一个 channel 中，然后监听 channel 来进行错误处理。官方提供了一项实验功能，可以用来解决这个问题。官方包在这里：golang....</p>
</section>
<footer class=entry-footer><span title="2021-08-16 18:40:38 +0800 CST">August 16, 2021</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;max</footer>
<a class=entry-link aria-label="post link to go-tips" href=https://www.soundpill.cn/posts/2021-08-16-go-tips/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>一道go面试题
</h2>
</header>
<section class=entry-content>
<p>一道 Go 面试题 请问下面这两段代码分别输出什么? 直接说结果, 如果你的电脑不是奔腾, 赛扬什么的处理器, 那结果基本是固定的, 就是啥也没有. 因为在 goroutine 反应过来之前, 程序已经执行完了, 还没来得及输出就结束了.
要么, 你就让时间延迟几秒再结束, time.Sleep(10 * time.Second), 要么就像下面这样使用 WaitGroup 来等待 goroutine 结束 这不是问题的重点, 重点是这两种使用匿名函数的方式, 输出会有什么不一样吗?
首先说第一种, 没有传参的情况下, 匿名函数中是使用的引用地址来操作的, 这时候 i 可能已经加到 10 了, 所以打印出来可能会是 10 个 10, 或者中间夹杂几个其他数字什么的. (而且这时候 goroutine 总是在 i++ 之后执行, 所以是从 1 - 10, 不是 0 - 9)
第二种情况, 显而易见就是乱序的了, 会把 0 - 9 挨个输出, 但是是乱序的</p>
</section>
<footer class=entry-footer><span title="2021-01-18 21:50:43 +0800 CST">January 18, 2021</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;max</footer>
<a class=entry-link aria-label="post link to 一道go面试题" href=https://www.soundpill.cn/posts/2021-01-18-go-question/></a>
</article>
<footer class=page-footer>
<nav class=pagination>
<a class=next href=https://www.soundpill.cn/posts/page/2/>Next Page »</a>
</nav>
</footer>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://www.soundpill.cn/>Beoning</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>